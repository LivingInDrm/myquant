# Backtest API Reference

This note summarizes six core APIs you will frequently touch when running QMT/xtquant with `quote_mode='history'` and `trade_mode='backtest'`: `passorder`, `get_trade_detail_data`, `ContextInfo.get_instrument_detail`, `ContextInfo.get_stock_list_in_sector`, `BackTestResult.get_backtest_index`, and `BackTestResult.get_group_result`. Together they cover the workflow of building a universe, submitting simulated orders, querying snapshots, and exporting reports when you run strategies through `xtquant.qmttools.run_strategy_file`.

## Prerequisites
- The script must be launched by `run_strategy_file`, which constructs the `ContextInfo` object (`C`) and registers lifecycle callbacks.
- Strategy code and the backtest runtime must share the same Python process so that `fetch_ContextInfo()` can locate the current context.
- Examples below focus on equities; other asset classes reuse the same APIs with different enum values.

---

## 1. `passorder`

**Purpose**  
Submit a simulated order. In history/backtest mode the runtime matches it immediately and updates the account snapshot synchronously.

**Import**
```python
from xtquant.qmttools.functions import passorder
```

**Signature**
```python
passorder(opType, orderType, accountid,
          orderCode, prType, modelprice, volume,
          strategyName, quickTrade, userOrderId,
          C)
```

**Key parameters**
- `opType`: operation type. For stocks, `23` = buy, `24` = sell.
- `orderType`: order type enum. For stocks, `1102` = buy, `1101` = sell.
- `accountid`: account identifier used by the backtest.
- `orderCode`: instrument code such as `600000.SH`.
- `prType`: price type, e.g. `11` for limit order.
- `modelprice`: price to submit.
- `volume`: order size (stocks must be multiples of 100).
- `strategyName`: tag used to separate data by strategy.
- `quickTrade`: set to `1` for standard usage.
- `userOrderId`: any remark you want to keep in the order record.
- `C`: the current `ContextInfo` instance supplied by the backtest engine.

**Example**
```python
def place_buy(C, account, stock_code, price, volume):
    passorder(
        23,                # buy
        1102,              # stock buy type
        account,
        stock_code,
        11,                # limit price
        float(price),
        volume,
        'momentum_strategy',
        1,                 # quickTrade
        'buy_signal',
        C
    )
```

**Notes**
- In history/backtest runs there is no asynchronous callback. Once `passorder` returns you can pull the latest holdings or cash via `get_trade_detail_data`.
- For algorithmic orders the runtime exposes `algo_passorder`, which accepts an extra `algoname` parameter.

---

## 2. `get_trade_detail_data`

**Purpose**  
Query snapshots maintained by the backtest engine: orders, trades, positions, and capital.

**Signature**
```python
get_trade_detail_data(accountid, accounttype, datatype, strategyname='')
```

**Parameters**
- `accountid`: account identifier.
- `accounttype`: instrument class string, e.g. `'stock'`.
- `datatype`: category to fetch. Common values:
  - `'POSITION'`: current holdings.
  - `'DEAL'`: trade fills.
  - `'ORDER'`: order records.
  - `'account'`: cash and equity.
- `strategyname`: optional filter. Leave blank to retrieve all strategies under the account.

**Return value**  
A list of lightweight objects (`DetailData`). Attributes correspond to CSV columns generated by the backtest engine, e.g.:
- Position fields: `m_strInstrumentID`, `m_strExchangeID`, `m_nVolume`, `m_dOpenPrice`, `m_nCanUseVolume`.
- Trade fields: `m_strDealID`, `m_strOrderSysID`, `m_dPrice`, `m_nVolume`, `m_dTurnover`.
- Account fields: `m_dAvailable`, `m_dTotalAsset`, `m_dMarketValue`.

**Example**
```python
from xtquant.qmttools.functions import get_trade_detail_data

def fetch_snapshot(account):
    positions = get_trade_detail_data(account, 'stock', 'POSITION', 'momentum_strategy')
    asset = get_trade_detail_data(account, 'stock', 'account', 'momentum_strategy')

    holdings = {
        f"{pos.m_strInstrumentID}.{pos.m_strExchangeID}": {
            'volume': pos.m_nVolume,
            'cost': pos.m_dOpenPrice,
            'available': pos.m_nCanUseVolume
        }
        for pos in positions
    }
    cash = asset[0].m_dAvailable if asset else 0.0
    return holdings, cash
```

**Notes**
- This helper must be executed inside the backtest/simulation runtime; otherwise `fetch_ContextInfo()` raises an exception.

### Datatype reference

**`ORDER` – Order snapshot**  
- **Use case**: Track the life cycle of every `passorder` submission (pending, partial fill, cancelled, rejected).  
- **Key fields**: `m_nOrderID`, `m_strOrderSysID`, `m_nStatus`, `m_nTradedVolume`, `m_dPrice`, `m_nVolume`, `m_strStatusMsg`.  
- **Typical pattern**: Maintain a dict keyed by `m_nOrderID` to monitor the latest status. Combine `m_nStatus` with your risk rules to decide whether to cancel, retry, or log errors. If `quickTrade=0`, use the snapshot to detect unfilled residuals that may require manual cancellation.

**`DEAL` – Fill records**  
- **Use case**: Inspect matched trades; a single order can generate multiple deal entries.  
- **Key fields**: `m_strDealID`, `m_strOrderSysID`, `m_dPrice`, `m_nVolume`, `m_dTurnover`, `m_nDirection`, `m_strStrategyName`.  
- **Typical pattern**: Deduplicate by `m_strDealID` when printing incremental fills or computing PnL. Link back to orders via `m_strOrderSysID` to evaluate execution quality.
- **Direction codes**: For equities the engine reports `23` for buy trades and `24` for sell trades (matching the constants used by `passorder`).

**`POSITION` – Holding snapshot**  
- **Use case**: Retrieve current holdings before generating signals or sizing positions.  
- **Key fields**: `m_strInstrumentID`, `m_strExchangeID`, `m_nVolume`, `m_nCanUseVolume`, `m_dOpenPrice`, `m_dFloatProfit`.  
- **Typical pattern**: Convert the list into a dictionary like `{code: {volume, cost, available}}` and sync it with your strategy’s in-memory position manager.

**`account` – Cash and equity snapshot**  
- **Use case**: Check cash availability, total asset value, and frozen funds.  
- **Key fields**: `m_dAvailable`, `m_dTotalAsset`, `m_dMarketValue`, `m_dFrozenCash`, `m_dWithdraw`.  
- **Typical pattern**: Read the first element (e.g., `asset[0]`) to obtain usable cash, then combine with `POSITION` data to calculate exposure, leverage, or drawdown.

---

## 3. `ContextInfo.get_instrument_detail`

**Purpose**  
Retrieve static instrument metadata (tick size, listing date, total shares, status, etc.) directly inside the backtest runtime.

**Signature**
```python
C.get_instrument_detail(stock_code='', iscomplete=False)
```

**Parameters**
- `stock_code`: instrument identifier (`'600000.SH'`). When omitted, the runtime uses `C.stock_code`.
- `iscomplete`: when `True`, returns the full detail map; otherwise a commonly used subset.

**Return value**  
A Python `dict` whose keys vary by instrument type (for equities: `InstrumentStatus`, `OpenDate`, `TotalVolume`, `TickSize`, `LotSize`, etc.).

**Example**
```python
def init(C):
    info = C.get_instrument_detail('600000.SH')
    tick = info.get('TickSize', 0.01)
    print(f"600000.SH tick size = {tick}")
```

**Notes**
- Combines well with `filter_opendate` logic—`OpenDate` tells you when the stock started trading.
- For batch queries, prefer `xtdata.get_instrument_detail` (vectorized), but `ContextInfo` keeps everything inside the backtest session without extra imports.

---

## 4. `ContextInfo.get_stock_list_in_sector`

**Purpose**  
Fetch the list of instruments that belong to a QMT-defined sector (e.g. "CSI300", "SSE A Shares").

**Signature**
```python
C.get_stock_list_in_sector(sector_name)
```

**Parameters**
- `sector_name`: sector identifier, such as `'CSI300'`, `'CSI500'`, `'STAR Market'`.

**Return value**  
A Python list of instrument codes (`['600000.SH', '000001.SZ', ...]`).

**Example**
```python
def init(C):
    g.stock_list = C.get_stock_list_in_sector('沪深300')
    print(f"universe size = {len(g.stock_list)}")
```

**Notes**
- The sector definitions rely on QMT’s static database; ensure the local data files are up to date.
- Combine with `get_instrument_detail` or `xtdata.get_market_data_ex` to pre-load prices for the entire universe.

---

## 5. `BackTestResult.get_backtest_index`

**Purpose**  
After the backtest run completes, retrieve performance statistics generated by the engine (annual return, max drawdown, Sharpe ratio, etc.).

**Usage pattern**
```python
from xtquant.qmttools import run_strategy_file

result = run_strategy_file(user_script, param=param)
if result:
    metrics = result.get_backtest_index()  # pandas.DataFrame
    print(metrics)
```

**Return value**  
A pandas `DataFrame` with one row of metrics; column names depend on the selected indicators (e.g. `annualized_return`, `sharpe_ratio`, `max_drawdown`).

**Notes**
- The helper writes CSV files to a temporary directory behind the scenes; no manual cleanup is required.
- Convert the DataFrame to JSON/CSV if you need to persist the metrics elsewhere.

---

## 6. `BackTestResult.get_group_result`

**Purpose**  
Export detailed order, deal, and position logs after the backtest finishes for auditing or custom analytics.

**Signature**
```python
result.get_group_result(fields=None)
```

**Parameters**
- `fields`: iterable specifying which CSVs to load. Defaults to `['order', 'deal', 'position']`. You can also request `['account']` if available.

**Return value**  
A dictionary mapping each requested field to a pandas `DataFrame`.

**Example**
```python
detail = result.get_group_result(['order', 'deal'])
orders = detail['order']
deals = detail['deal']
print(f"orders={len(orders)}, deals={len(deals)}")
```

**Notes**
- The exported DataFrames mirror the structure returned by `get_trade_detail_data` but cover the entire backtest horizon.
- Useful for reconciling simulated trades with strategy logs or feeding the data into custom reporting pipelines.

---

## Putting it together
```python
from xtquant.qmttools import run_strategy_file
from xtquant.qmttools.functions import passorder, get_trade_detail_data

ACCOUNT = 'demo_account'
STRATEGY = 'demo_strategy'
SECTOR = 'CSI300'

g = {
    'universe': [],
}

def init(C):
    # Build trading universe and inspect instrument metadata
    g['universe'] = C.get_stock_list_in_sector(SECTOR)
    if g['universe']:
        info = C.get_instrument_detail(g['universe'][0])
        print(f"Universe first symbol {g['universe'][0]} listed on {info.get('OpenDate')}")

def fetch_snapshot(account):
    positions = get_trade_detail_data(account, 'stock', 'POSITION', STRATEGY)
    asset = get_trade_detail_data(account, 'stock', 'account', STRATEGY)
    cash = asset[0].m_dAvailable if asset else 0.0
    return positions, cash

def handlebar(C):
    positions, cash = fetch_snapshot(ACCOUNT)
    print(f"bar={C.barpos} holdings={len(positions)} cash={cash:.2f}")
    if cash > 10000 and g['universe']:
        code = g['universe'][C.barpos % len(g['universe'])]
        passorder(23, 1102, ACCOUNT, code, 11, 10.0, 100,
                  STRATEGY, 1, f"buy_{C.barpos}", C)
        # Optional: pull a fresh snapshot right after the order
        positions, cash = fetch_snapshot(ACCOUNT)
        print(f"  post-trade holdings={len(positions)} cash={cash:.2f}")

if __name__ == '__main__':
    param = {
        'stock_code': '000001.SZ',
        'period': '1d',
        'start_time': '2023-01-01 00:00:00',
        'end_time': '2023-12-31 00:00:00',
        'trade_mode': 'backtest',
        'quote_mode': 'history'
    }
    result = run_strategy_file(__file__, param=param)
    if result:
        metrics = result.get_backtest_index()
        detail = result.get_group_result(['order', 'deal'])
        print("Backtest metrics:\n", metrics)
        print("First few deals:\n", detail['deal'].head())
```

Using these interfaces together lets you construct universes, inspect instrument metadata, submit and monitor simulated orders, query bar-by-bar snapshots, and finally export consolidated reports straight from the backtest engine.
